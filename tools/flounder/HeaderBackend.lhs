%include polycode.fmt

%if false
  Flounder2: an even more simpler IDL for Barrelfish
   
  Copyright (c) 2009 ETH Zurich.
  All rights reserved.
  
  This file is distributed under the terms in the attached LICENSE file.
  If you do not find this file, copies can be found by writing to:
  ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
%endif


\section{The Header Back-End}

Here, we are provided a syntactically correct syntax tree and we want
to compile it into a (valid) C header file.

> module HeaderBackend where

%if false

> import Debug.Trace
> import Data.List
> import Data.Char

> import qualified CSyntax as C
> import Backend
> import Syntax

%endif

Every header starts with the same story: first the preamble, then the
body. We do not make exception. The preamble is generated by the
so-called @preamble@ function whereas the main processing is undertook
by @compileInterface@. This function computes the @body@ of the header
file, ie. does the real work.

> compile :: String -> String -> Interface -> String
> compile infile baseName interface@(Interface interfaceName _ _) =
>     preamble interface infile
>  ++ C.header_file filename body
>      where filename = interfaceName ++ "_types"
>            body = compileInterface interface



\subsection{Interface Compilation}

Here, we build the @compileInterface@ function that compiles our
domain-specific language to a C header file. It is decomposed in the
following steps:
\begin{enumerate}
        \item Include several files
        \item Compile the data-types definitions
        \item Compile the marshaling functions
        \item Compile the message functions prototypes
        \item Compile an enumeration of all message functions
        \item Compile the VTable types for proxies
        \item Compile the callback types
        \item Compile the server listen function
        \item Expose the server request handler prototype
        \item Expose the client request handler prototype
        \item Compile the client connect function
        \item Expose the client call vtable
        \item Expose the server response vtable
        \item Take a coffee
\end{enumerate}

> compileInterface :: Interface -> String
> compileInterface interface@(Interface name description declaration) = 
>     let (types, messages) = partitionTypesMessages declaration in
>         unlines $
>                 include [
>                           "flounder/oldflounder",
>                           "flounder/glue_internal"
>                         ] 
>                 ++ C.multi_comment1 "Data type definitions"
>                 ++ compileTypes name types
>                 ++ C.multi_comment1 "Marshalling functions"
>                 ++ compileMarshals name types
>                 ++ C.multi_comment1 "Message function types"
>                 ++ compileMessages name messages
>                 ++ C.multi_comment1 "Enumeration for message codes"
>                 ++ compileEnums name messages
>                 ++ C.multi_comment1 "Vtables for proxies"
>                 ++ compileVtable name messages
>                 ++ C.multi_comment1 "Server listen function" 
>                 ++ compileServerListen name 
>                 ++ C.multi_comment1 "Server request handler"
>                 ++ compileServerRequestHandler name 
>                 ++ C.multi_comment1 "Client request handler"
>                 ++ compileClientRequestHandler name 
>                 ++ C.multi_comment1 "Client connect function"
>                 ++ compileClientConnect name
>                 ++ C.multi_comment1 "Client call vtable"
>                 ++ compileClientCallVtable name
>                 ++ C.multi_comment1 "Server response vtable"
>                 ++ compileServerResponseVtable name


\subsubsection{Generate Includes}


To generate the includes, we simply map the list of files over the
include function defined in @CSyntax@:

> include :: [String] -> [String]
> include = map C.include 


\subsubsection{Compiling Types}


First of all, we don't need to compile builtin types, by
definition. So, we filter out builtin types from the list of types to
be compiled down. Then, we just have to individually compile each
type, thanks to @compileType@.

> compileTypes :: String -> [TypeDef] -> [String]
> compileTypes interfaceName types = 
>      concat
>      [ compileType interfaceName typeT 
>        | typeT <- types ]

So, let us compile constructed types now. 

> compileType :: String -> TypeDef -> [String]

A transparent alias doesn't need to be translated:

> compileType interfaceName (TAliasT newType originType) = []

A typedef'd alias:
\begin{verbatim}
typedef uint32 alias_type;
\end{verbatim}

Should compile to:
\begin{verbatim}
typedef uint32_t ifname_alias_type_t;
\end{verbatim}

> compileType interfaceName (TAlias newType originType) = 
>     C.typedef (qualifyType interfaceName 
>                            (var newType))
>               (qualifyType interfaceName 
>                            originType) : []

For @TArray@, we have to map the type @name@ to an array of @length@
elements of type @typeElts@. In C, this surprisingly corresponds to
the, correct, following code:

\begin{verbatim} 
typedef typeElts name[length]
\end{verbatim}

So, we will compile:
\begin{verbatim}
typedef uint32 array_type[30];
\end{verbatim}

To the following type definition:
\begin{verbatim}
typedef uint32_t ifname_array_type_t[30]
\end{verbatim}

> compileType interfaceName (TArray typeElts name length) = 
>     C.typedef ((qualifyType interfaceName (var name))
>                 ++ "[" ++ show length ++ "]")
>               (qualifyType interfaceName 
>                            typeElts) : []


The following structure:
\begin{verbatim}
typedef struct {
    uint32 int_field;
    alias_type alias_field;
} struct_type;
\end{verbatim}

Should be compiled down to:
\begin{verbatim}
typedef struct _ifname_struct_type_t {
    uint32_t    int_field;
    ifname_alias_type_t    alias_field;
} ifname_struct_type_t;
\end{verbatim}

> compileType interfaceName (TStruct name fields) = 
>     (C.typedef (qualifyType interfaceName (var name))
>               (concat 
>                  (C.struct 
>                      ("_" ++ qualifyType interfaceName (var name))
>                      [ C.struct_field (qualifyType interfaceName 
>                                                    typeField)
>                                        name 
>                        | TStructField typeField name <- fields ] ))) : []

This enumeration:
\begin{verbatim}
typedef enum {
    foo, bar, baz
} some_enum;
\end{verbatim}

Generates the following code:
\begin{verbatim}
enum ifname_some_enum_t {
    ifname_some_enum_t_foo = 1,
    ifname_some_enum_t_bar = 2,
    ifname_some_enum_t_baz = 3,
}
\end{verbatim}

> compileType interfaceName (TEnum name elements) = 
>     let tagged_elements = map (\ elt -> qualifiedName ++ "_" ++ elt) elements in
>     let index_elements = map show [1..] in
>         C.typedef qualifiedName 
>              (concat (C.enum_anon ("_" ++ qualifiedName)
>                            (zip tagged_elements index_elements))) : []
>         where qualifiedName = qualifyType interfaceName (var name)


\subsubsection{Compiling Marshalling functions}

As for types, generating marshalling functions consists of
individually generating the marshalling function for each non trivial
type.

> compileMarshals :: String -> [TypeDef] -> [String]
> compileMarshals interfaceName types = 
>     concat
>         [ compileMarshal interfaceName t 
>           | t <- types ]

The compilation of:
\begin{verbatim}
typedef uint32 alias_type;
\end{verbatim}

Should generate:
\begin{verbatim}
static inline errval_t FL_MARSHAL_ifname_alias_type( struct msgbuf * msg, ifname_alias_type_t val )
{
    return FL_MARSHAL_uint32(msg, val);
}
static inline errval_t FL_UNMARSHAL_ifname_alias_type( struct msgbuf * msg, ifname_alias_type_t* val )
{
    errval_t err;
    uint64_t tmp;
    err = FL_UNMARSHAL_uint32(msg, &tmp);
    if (err_is_ok(err)) { *val = tmp; }
    return err;
}
\end{verbatim}

> compileMarshal :: String -> TypeDef -> [String]
> compileMarshal interfaceName (TAlias newType originType) = 
>     C.inline "errval_t" 
>          ("FL_MARSHAL_" ++ qualifyName interfaceName 
>                                        (var newType))
>          [
>            ("struct msgbuf *", "msg"),
>            (qualifyType interfaceName (var newType), "val")
>          ]
>          [
>             "return FL_MARSHAL_" 
>              ++ qualifyName interfaceName originType 
>              ++ "(msg, val);"
>          ]
>  ++ C.inline "errval_t"
>         ("FL_UNMARSHAL_" ++ qualifyName interfaceName 
>                                        (var newType))
>          [
>            ("struct msgbuf *", "msg"),
>            (qualifyType interfaceName (var newType) ++ "*", "val")
>          ]
>          (
>           [
>            "return FL_UNMARSHAL_" ++ qualifyName interfaceName originType ++ "(msg, val);"
>           ] )


The compilation of:
\begin{verbatim}
alias size_t uint64;
\end{verbatim}

Should generate:
\begin{verbatim}
static inline errval_t FL_MARSHAL_ifname_size_t( struct msgbuf * msg, size_t val )
{
    return FL_MARSHAL_uint64(msg, val);
}
static inline errval_t FL_UNMARSHAL_ifname_size_t( struct msgbuf * msg, size_t* val )
{
    return FL_UNMARSHAL_uint64(msg, val);
}
\end{verbatim}


> compileMarshal interfaceName (TAliasT newType originType) = 
>     C.inline "errval_t" 
>          ("FL_MARSHAL_" ++ qualifyName interfaceName 
>                                        (als newType originType))
>          [
>            ("struct msgbuf *", "msg"),
>            (qualifyType interfaceName (als newType originType), "val")
>          ]
>          [
>             "return FL_MARSHAL_" 
>              ++ qualifyName interfaceName originTypeB 
>              ++ "(msg, val);"
>          ]
>  ++ C.inline "errval_t"
>         ("FL_UNMARSHAL_" ++ qualifyName interfaceName 
>                                        (als newType originType))
>          [
>            ("struct msgbuf *", "msg"),
>            (qualifyType interfaceName (als newType originType) ++ "*", "val")
>          ]
>          (
>           [
>            "return FL_UNMARSHAL_" ++ qualifyName interfaceName originTypeB ++ "(msg, val);"
>           ] )
>             where originTypeB = Builtin originType


The compilation of:
\begin{verbatim}
typedef uint32 array_type[30];
\end{verbatim}

Should generate:
\begin{verbatim}
static inline errval_t FL_MARSHAL_ifname_array_type( struct msgbuf * msg, ifname_array_type_t val )
{
    return FL_MARSHAL_buffer(msg, val, sizeof(uint32_t) * 30);
}
static inline errval_t FL_UNMARSHAL_ifname_array_type( struct msgbuf * msg, ifname_array_type_t * val )
{
    return FL_UNMARSHAL_buffer(msg, (void **) val);
}
\end{verbatim}

> compileMarshal interfaceName (TArray typeElts name length) =
>     C.inline "errval_t"
>          ("FL_MARSHAL_" ++ qualifyName interfaceName
>                                        (var name))
>          [
>           ("struct msgbuf *", "msg"),
>           (qualifyType interfaceName (var name), "val")
>          ]
>          [
>           "return FL_MARSHAL_buffer(msg, val, sizeof(" 
>             ++ qualifyType interfaceName typeElts ++ ") * " 
>             ++ show length ++ ");"
>          ]
>  ++ C.inline "errval_t"
>          ("FL_UNMARSHAL_" ++ qualifyName interfaceName 
>                                          (var name))
>          [
>           ("struct msgbuf *", "msg"),
>           (qualifyType interfaceName (var name) ++ " *", "val")
>          ]
>          [
>           "return FL_UNMARSHAL_buffer(msg, (void **) val);"
>          ]


The compilation of:
\begin{verbatim}
typedef enum {
    foo, bar, baz
} some_enum;
\end{verbatim}

Which compiles to:
\begin{verbatim}
static inline errval_t FL_MARSHAL_ifname_some_enum( struct msgbuf * msg, enum _ifname_some_enum_t val )
{
    return FL_MARSHAL_uint32(msg, val);
}
static inline errval_t FL_UNMARSHAL_ifname_some_enum( struct msgbuf * msg, enum _ifname_some_enum_t * val )
{
    return FL_UNMARSHAL_uint32(msg, val);
}
\end{verbatim}

> compileMarshal interfaceName (TEnum name elements) =
>     C.inline "errval_t"
>          ("FL_MARSHAL_" ++ qualifyName interfaceName (var name))
>          [
>           ("struct msgbuf *", "msg"),
>           ("enum _" ++ qualifyType interfaceName (var name), "val")
>          ]
>          [
>           "return FL_MARSHAL_uint32(msg, val);"
>          ]
>  ++ C.inline "errval_t"
>          ("FL_UNMARSHAL_" ++ qualifyName interfaceName (var name))
>          [
>           ("struct msgbuf *", "msg"),
>           ("enum _" ++ qualifyType interfaceName (var name) ++ " *", "val")
>          ]
>          [
>           "return FL_UNMARSHAL_uint32(msg, val);"
>          ]

The compilation of:
\begin{verbatim}
typedef struct {
 uint32 int_field;
 alias_type alias_field;
} struct_type;
\end{verbatim}

Which compiles to:

\begin{verbatim}
static inline errval_t FL_MARSHAL_ifname_struct_type( struct msgbuf * msg, struct _ifname_struct_type_t val )
{
    errval_t err;
    err = FL_MARSHAL_uint32(msg, val.int_field);
    if (err_is_fail(err)) return err;
    err = FL_MARSHAL_ifname_alias_type(msg, val.alias_field);
    if (err_is_fail(err)) return err;
    return err;
}
static inline errval_t FL_UNMARSHAL_ifname_struct_type( struct msgbuf * msg, struct _ifname_struct_type_t * val )
{
    errval_t err;
    uint64_t tmp_int_field;
    err = FL_UNMARSHAL_uint32(msg, &tmp_int_field);
    if (err_is_ok(err)) { val->int_field = tmp_int_field; }
    if (err_is_fail(err)) return err;
    err = FL_UNMARSHAL_ifname_alias_type(msg, &(val->alias_field));
    if (err_is_fail(err)) return err;
    return err;
}
\end{verbatim}

> compileMarshal interfaceName (TStruct name fields) = 
>     C.inline "errval_t"
>          ("FL_MARSHAL_" ++ qualifyName interfaceName (var name))
>          [
>           ("struct msgbuf *", "msg"),
>           ("struct _" ++ qualifyType interfaceName (var name), "val")
>          ]
>          ( [ "errval_t err;" ]
>         ++ concat [ [ 
>                    "err = FL_MARSHAL_" ++ qualifyName interfaceName typeField ++ "(msg, val." ++ nameField ++ ");",
>                    "if (err_is_fail(err)) return err;"
>                    ]
>                     | TStructField typeField nameField <- fields ]
>         ++ [ "return err;" ]
>          )
>  ++ C.inline "errval_t"
>         ("FL_UNMARSHAL_" ++ qualifyName interfaceName (var name))
>         [
>          ("struct msgbuf *", "msg"),
>          ("struct _" ++ qualifyType interfaceName (var name) ++ " *", "val")
>         ]
>          ( [ "errval_t err;" ]
>         ++ concat [  
>                    ( [ "err = FL_UNMARSHAL_" ++ qualifyName interfaceName typeField ++ "(msg, &(val->" ++ nameField ++ "));" ] )
>                    ++ [ "if (err_is_fail(err)) return err;" ]
>                      | TStructField typeField nameField <- fields ]
>         ++ [ "return err;" ]
>          )
  


\subsubsection{Compiling Messaging functions}

The compilation of message definition follows the usual
pattern. First, we compile each message definition individually.

> compileMessages :: String -> [MessageDef] -> [String]
> compileMessages interfaceName messages = 
>     ("struct " ++ interfaceName ++ "_service_response;") :
>     ("struct " ++ interfaceName ++ "_client_response;") :
>     (concat $ map (compileMessageProto interfaceName) messages)

Then, we have to generate function prototypes, independently whether
it is a @Message@, a @Call@, or a @Response@. Given the following code:
\begin{verbatim}
message initmsg( uint32 someint, cap somecap, iref some_if, string some_string );
\end{verbatim}

It must generates:
\begin{verbatim}
typedef void ifname_initmsg_service_handler_fn( struct ifname_service_response * st, 
                                                uint32_t someint, 
                                                cap_t somecap, 
                                                iref_t some_if, 
                                                char * some_string );
typedef void ifname_initmsg_client_handler_fn( struct ifname_client_response * st, 
                                               uint32_t someint, 
                                               cap_t somecap, 
                                               iref_t some_if, 
                                               char * some_string );
typedef errval_t ifname_initmsg_client_sender_fn( struct ifname_client_reponse * st,  
                                           uint32_t someint,  
                                           cap_t somecap,  
                                           iref_t some_if, 
                                           const char * some_string );
typedef errval_t ifname_initmsg_client_sender_fn( struct ifname_service_reponse * st,  
                                           uint32_t someint,  
                                           cap_t somecap,  
                                           iref_t some_if, 
                                           const char * some_string );
\end{verbatim}

The distinction between \emph{handler} and \emph{sender} stands in the
\emph{const} type for strings. When we \emph{send} a string, we want
to ensure that this string is not modified by the stub. On the other
hand, we are free to modify a string when we \emph{handle} in a message. 


And the typedefs written above are generated by the following code:

> compileMessageProto :: String -> MessageDef -> [String]
> compileMessageProto interfaceName m@(Message msgType name args) =
>     [C.function_proto "typedef" 
>                      "void" 
>                      (qualifyProcName interfaceName (var $ name ++ "_service_handler"))
>                      (compileMessageArgs ServerSide args) ++ ";",
>     C.function_proto "typedef" 
>                      "void" 
>                      (qualifyProcName interfaceName (var $ name ++ "_client_handler"))
>                      (compileMessageArgs ClientSide args) ++ ";",
>     C.function_proto "typedef" 
>                      "errval_t" 
>                      (qualifyProcName interfaceName (var $ name ++ "_service_sender"))
>                      (compileCommonDefinitionArgs interfaceName ServerSide m) ++ ";",
>     C.function_proto "typedef" 
>                      "errval_t" 
>                      (qualifyProcName interfaceName (var $ name ++ "_client_sender"))
>                      (compileCommonDefinitionArgs interfaceName ClientSide m) ++ ";"]
>     where compileMessageArgs ClientSide args =
>               [("struct " ++ interfaceName ++ "_client_response *", "st")] 
>               ++ [(qualifyType interfaceName typeArg, (nameOf identifier))
>                  | Arg typeArg identifier <- args ]
>           compileMessageArgs ServerSide args =
>               [("struct " ++ interfaceName ++ "_service_response *", "st")] 
>               ++ [(qualifyType interfaceName typeArg, (nameOf identifier))
>                  | Arg typeArg identifier <- args ]

> compileMessageProto interfaceName m@(RPC name args) =
>     [C.function_proto "typedef" 
>                      "void" 
>                      (qualifyProcName interfaceName (var $ name ++ "_service_handler"))
>                      (compileMessageArgs args) ++ ";",
>     C.function_proto "typedef" 
>                      "void" 
>                      (qualifyProcName interfaceName (var $ name ++ "_client_handler"))
>                      [("void", "")] ++ ";",
>     C.function_proto "typedef" 
>                      "errval_t" 
>                      (qualifyProcName interfaceName (var $ name ++ "_client_sender"))
>                      (compileRPCDefinitionArgs interfaceName args) ++ ";" ,
>     C.function_proto "typedef" 
>                       "errval_t" 
>                      (qualifyProcName interfaceName (var $ name ++ "_service_sender"))
>                      (compileRPCOutArgs args) ++ ";"]
>     where compileMessageArgs args =
>               [ ("struct " ++ interfaceName ++ "_service_response *", "st")] 
>               ++ [ let RPCArgIn typeArg identifier = arg in
>                    (qualifyType interfaceName typeArg, (nameOf identifier))
>                  | arg <- args,
>                    case arg of
>                    RPCArgOut _ _ -> False
>                    RPCArgIn _ _ -> True ]
>           compileRPCOutArgs args =
>               [ ("struct " ++ interfaceName ++ "_service_response *", "_st")] 
>               ++ [ let RPCArgOut typeArg identifier = arg in
>                    (qualifyType interfaceName typeArg, (nameOf identifier))
>                  | arg <- args,
>                    case arg of
>                    RPCArgIn _ _ -> False
>                    RPCArgOut _ _ -> True ]


\subsubsection{Compiling Message Enumerations}

We symbolically identifies message handlers in an enumeration. Hence,
we simply list all message function name, under the representation
@ifname_message_fc@.

For the following code:
\begin{verbatim}
message simplemsg(uint32 someint);
message withstrmsg(alias_type at);
message initmsg(uint32 someint, cap somecap, iref some_if, 
	        string some_string);
call forwards();
response backwards();
\end{verbatim}

This leads to:
\begin{verbatim}
enum ifname_function_codes {
    IFNAME_SIMPLEMSG_FC = 1,
    IFNAME_WITHSTRMSG_FC = 2,
    IFNAME_INITMSG_FC = 3,
    IFNAME_FORWARDS_FC = 4,
    IFNAME_BACKWARDS_FC = 5,
};
\end{verbatim}

Generated by the following code:

> compileEnums :: String -> [MessageDef] -> [String]
> compileEnums interfaceName messages = 
>     let indexes = map show [1..] in
>     let messageNames = map (\msg -> let name = case msg of
>                                                  Message _ name _ -> name
>                                                  RPC name _ -> name in
>                                       map toUpper interfaceName ++ 
>                                               "_" ++ 
>                                               map toUpper name 
>                                               ++ "_FC") messages in
>         (C.enum_anon (interfaceName ++ "_function_codes") $
>                      zip messageNames indexes)
>         ++ ";" : []

\subsubsection{Compiling the VTables}

The VTables are not the most funny things to code. But they are not
tricky at all. Given a set of messages, we build 8 structures
containing various handlers for these messages. The big picture is
given by the following code.

> compileVtable :: String -> [MessageDef] -> [String]
> compileVtable interfaceName messages = 
>     [compileVtableTypedefServerDisconnect interfaceName]
>  ++ [compileVtableTypedefServerConnect interfaceName]
>  ++ [compileVtableTypedefServerListen interfaceName]
>  ++ compileVtableServerResponse interfaceName messages 
>  ++ compileVtableServerRespHandlers interfaceName
>  ++ compileVtableServerCall interfaceName messages
>  ++ compileVtableService interfaceName
>  ++ [compileVtableTypedefClientConnected interfaceName]
>  ++ [compileVtableTypedefClientDisconnect interfaceName]
>  ++ compileVtableClientCall interfaceName messages
>  ++ compileVtableClientResponse interfaceName messages
>  ++ compileVtableClientResp interfaceName

May I say that the following codes speak by themselves? Actually, they
are simply the encoding of the structures we are willing to build.

Again, we will distinguish \emph{handler} from \emph{sender} stubs:

> data StubSide = Handler Side
>               | Sender Side
>
> instance Show StubSide where
>     show (Handler ServerSide) = "service_handler"
>     show (Handler ClientSide) = "client_handler"
>     show (Sender ServerSide) = "service_sender"
>     show (Sender ClientSide) = "client_sender"

In the following, we work with the set of messages defined above. 

It is set up by the user with a handler for each event handlers,
disconnect, listening, and connected callbacks.

> compileVtableTypedefServerDisconnect :: String -> String
> compileVtableTypedefServerDisconnect interfaceName =
>     unlines [ "struct " ++ interfaceName ++ "_server_response;",
>               "struct " ++ interfaceName ++ "_service;",
>       C.typedef ("(*" ++ interfaceName 
>                  ++ "_server_disconnect_cb)(struct " ++ interfaceName ++ "_service_response *st)")
>       "void" ] 
>
> compileVtableTypedefServerConnect :: String -> String
> compileVtableTypedefServerConnect interfaceName =
>       C.typedef ("(*" ++ interfaceName 
>                  ++ "_server_connect_cb)(struct " ++ interfaceName ++ "_service_response *closure)")
>       "errval_t"
>
> compileVtableTypedefServerListen :: String -> String
> compileVtableTypedefServerListen interfaceName =
>       C.typedef ("(*" ++ interfaceName 
>                  ++ "_server_listen_cb)(struct " ++ interfaceName ++ "_service *st," ++
>                                  "iref_t iref)")
>       "void"


The server response vtable should look like this:

\begin{verbatim}
struct ifname_server_response_vtbl {
    ifname_simplemsg_service_sender_fn *simplemsg;
    ifname_withstrmsg_service_sender_fn *withstrmsg;
    ifname_initmsg_service_sender_fn *initmsg;
    ifname_backwards_service_sender_fn *backwards;
    chips_disconnect_handler_t	_disconnect;
};
\end{verbatim}


> compileVtableServerResponse :: String -> [MessageDef] -> [String]
> compileVtableServerResponse interfaceName messages =
>     
>    (C.struct (interfaceName ++ "_server_response_vtbl") 
>          ((makeHandlerFields interfaceName isBackward (Sender ServerSide) messages)
>       ++ [ C.struct_field (interfaceName ++ "_server_disconnect_cb") "_disconnect" ]))
>    ++ [";"]

The server service response closure should look like this:

\begin{verbatim}
struct ifname_service_response {
    struct ifname_server_response_vtbl *f;
    struct idc_chan chan;
    void *st;
    struct ifname_service *sclp;
};
\end{verbatim}

Which points to the server response vtable, a chips connection, a
local state, and a server service closure.

> compileVtableServerRespHandlers :: String -> [String]
> compileVtableServerRespHandlers interfaceName =
>    (C.struct (interfaceName ++ "_service_response")
>          [
>           C.struct_field ("struct " ++ interfaceName ++ "_server_response_vtbl *") "f",
>           C.struct_field "struct flounder_glue_binding *" "chan",
>           C.struct_field "void *" "st",
>           C.struct_field "struct msgbuf" "sendmsg[2]",
>           C.struct_field "int" "nsendmsg",
>           C.struct_field ("struct " ++ interfaceName ++ "_service *") "sclp"
>          ]) ++ [";"]


The server call vtable should look as follow:

\begin{verbatim}
struct ifname_server_response;
typedef void (*ifname_disconnect_cb)(struct ifname_service_response *st);

struct ifname_server_call_vtbl {
    ifname_simplemsg_service_handler_fn *	simplemsg;
    ifname_withstrmsg_service_handler_fn *	withstrmsg;
    ifname_initmsg_service_handler_fn *	initmsg;
    ifname_forwards_service_handler_fn *	forwards;
    ifname_disconnect_cb	_disconnect;
    chips_listen_callback_t	_listening;
    connect_callback_t	_connected;
}
\end{verbatim}

 
> compileVtableServerCall :: String -> [MessageDef] -> [String]
> compileVtableServerCall interfaceName messages =
>    (C.struct (interfaceName ++ "_server_call_vtbl")
>          ((makeHandlerFields interfaceName isForward (Handler ServerSide) messages)
>       ++ [ C.struct_field (interfaceName ++ "_server_disconnect_cb") "_disconnect" ,
>            C.struct_field (interfaceName ++ "_server_listen_cb") "_listening",
>            C.struct_field (interfaceName ++ "_server_connect_cb") "_connected"])) ++ [";"]


The service closure is allocated per-client and allows the server to
maintain per-client state and call vtable. The code should look like
this:

\begin{verbatim}
struct ifname_service {
    struct ifname_server_call_vtbl *f;
    uintptr_t flags;
    void *st;
};
\end{verbatim}

And is generated by:

> compileVtableService :: String -> [String]
> compileVtableService interfaceName =
>     (C.struct (interfaceName ++ "_service")
>           [
>            C.struct_field ("struct " ++ interfaceName ++ "_server_call_vtbl *") "f",
>            C.struct_field "uintptr_t" "flags",
>             C.struct_field "void *" "st"
>           ]) ++ [";"]

Client side, we also have typedefs:

> compileVtableTypedefClientConnected :: String -> String
> compileVtableTypedefClientConnected interfaceName =
>      unlines [ "struct " ++ interfaceName ++ "_client_response;",
>       C.typedef ("(*" ++ interfaceName 
>                       ++ "_client_connected_cb)(struct " ++ interfaceName ++ "_client_response *st)")
>            "void" ]
>
> compileVtableTypedefClientDisconnect :: String -> String
> compileVtableTypedefClientDisconnect interfaceName =
>       C.typedef ("(*" ++ interfaceName 
>                  ++ "_client_disconnect_cb)(struct " ++ interfaceName ++ "_client_response *st)")
>       "void"

On the client side, there is also a call vtable looking like this:

\begin{verbatim}
struct ifname_client_call_vtbl {
    ifname_simplemsg_client_sender_fn *	simplemsg;
    ifname_withstrmsg_client_sender_fn *	withstrmsg;
    ifname_initmsg_client_sender_fn *	initmsg;
    ifname_forwards_client_sender_fn *	forwards;
    chips_disconnect_handler_t	_disconnect;
};
\end{verbatim}

Generated by:

> compileVtableClientCall :: String -> [MessageDef] -> [String]
> compileVtableClientCall interfaceName messages =
>     (C.struct (interfaceName ++ "_client_call_vtbl")
>           ((makeHandlerFields interfaceName isForward (Sender ClientSide) messages)
>           ++ [ C.struct_field (interfaceName ++ "_client_disconnect_cb") "_disconnect"])) ++ [";"]

The client response vtable looks like this:

\begin{verbatim}
struct ifname_client_response;
typedef void (*ifname_connected_cb)(struct ifname_client_response *st);

struct ifname_client_response_vtbl {
    ifname_simplemsg_client_handler_fn *simplemsg;
    ifname_withstrmsg_client_handler_fn *withstrmsg;
    ifname_initmsg_client_handler_fn *initmsg;
    ifname_backwards_client_handler_fn *backwards;
    chips_disconnect_handler_t	_disconnect;
    ifname_connected_cb	_connected;
};
\end{verbatim}


> compileVtableClientResponse :: String -> [MessageDef] -> [String]
> compileVtableClientResponse interfaceName messages =
>     (C.struct (interfaceName ++ "_client_response_vtbl")
>           ((makeHandlerFields interfaceName isBackward (Handler ClientSide) messages)
>           ++ [ C.struct_field (interfaceName ++ "_client_disconnect_cb") "_disconnect",
>                C.struct_field (interfaceName ++ "_client_connected_cb") "_connected" ])) ++ [";"]

Finally, the client closure looks like this:

\begin{verbatim}
struct ifname_client_response {
    struct ifname_client_response_vtbl *	f;
    struct ifname_client_call_vtbl *	call_vtbl;
    struct idc_chan chan;
    void *	st;
};
\end{verbatim}

Generated by the following code:

> compileVtableClientResp :: String -> [String]
> compileVtableClientResp interfaceName =
>     (C.struct (interfaceName ++ "_client_response")
>           [ C.struct_field ("struct " ++ interfaceName ++ "_client_response_vtbl *") "f",
>             C.struct_field ("struct " ++ interfaceName ++ "_client_call_vtbl *") "call_vtbl",
>             C.struct_field "struct flounder_glue_binding *" "chan",
>             C.struct_field "void *" "st",
>             C.struct_field "struct msgbuf" "sendmsg[2]",
>             C.struct_field "int" "nsendmsg",
>             -- should emit these only conditionally on RPC, but bleh...
>             C.struct_field "struct msgbuf *" "replymsg",
>             C.struct_field "bool" "reply_present",
>             C.struct_field "struct waitset" "rpc_waitset"
>            ]) ++ [";"]


> makeHandlerFields :: String -> (MessageDef -> Bool) -> StubSide -> [MessageDef] -> [String]
> makeHandlerFields interfaceName classPredicate stubSide messages =
>     [ 
>       case message of 
>       Message _ messageName _ -> 
>           C.struct_field (interfaceName ++ "_" ++ messageName ++ "_" ++ show stubSide ++ "_fn *")
>                           messageName
>       RPC messageName _ -> 
>           C.struct_field (interfaceName ++ "_" ++ messageName ++ "_" ++  show stubSide ++ "_fn *")
>                          messageName
>       | message <- messages,
>         classPredicate message ] 


\subsubsection{Compiling the Server Listen Prototype}

Here, we have just to output the prototype of the server's listen
function:

\begin{verbatim}
extern errval_t ifname_listen( struct ifname_service * closure );
\end{verbatim}

> compileServerListen :: String -> [String]
> compileServerListen interfaceName =
>     [
>      (C.function_proto "extern" "errval_t" (interfaceName ++ "_listen")
>            [("struct " ++ interfaceName ++ "_service *", "closure")]) ++ ";"
>     ]

\subsubsection{Compiling the Server Request Handler}

The prototype of the exported server request handler is the following:

\begin{verbatim}
struct msgbuf * ifname_server_request_handler( void * _cl, struct msgbuf * _msg );
\end{verbatim}

As generated by:

> compileServerRequestHandler :: String -> [String]
> compileServerRequestHandler interfaceName =
>     [
>      (C.function_proto "" "void" (interfaceName ++ "_server_request_handler")
>            [("void * ", "_cl"),("struct msgbuf *", "_msg")]) ++ ";"
>     ]
    

\subsubsection{Compiling the Client Request Handler}

The prototype of the exported client request handler is the following:

\begin{verbatim}
struct msgbuf * ifname_client_request_handler( void *  _cl, struct msgbuf * _msg );
\end{verbatim}

As generated by:

> compileClientRequestHandler :: String -> [String]
> compileClientRequestHandler interfaceName =
>     [
>      (C.function_proto "" "void" (interfaceName ++ "_client_request_handler")
>            [("void * ", "_cl"),("struct msgbuf *", "_msg")]) ++ ";"
>     ]
    

\subsubsection{Compiling Client Connection Function}

The same goes for the client connection function:

\begin{verbatim}
extern errval_t ifname_connect( iref_t iref, struct ifname_client_response * resp_cl );
\end{verbatim}

> compileClientConnect :: String -> [String]
> compileClientConnect interfaceName = 
>     [
>      (C.function_proto "extern" "errval_t" (interfaceName ++ "_connect")
>            [
>             ("iref_t", "iref"),
>             ("struct " ++ interfaceName ++ "_client_response *", "resp_cl"),
>             ("size_t", "buflen")
>            ]) ++ ";"
>     ]


\subsubsection{Compiling the Client Call Vtable}

> compileClientCallVtable :: String -> [String]
> compileClientCallVtable interfaceName = 
>     ["extern struct " ++ interfaceName ++ "_client_call_vtbl the_" ++ interfaceName ++ "_client_call_vtbl;"]

\subsubsection{Compiling the Server Response Vtable}

> compileServerResponseVtable :: String -> [String]
> compileServerResponseVtable interfaceName = 
>     ["extern struct " ++ interfaceName ++ "_server_response_vtbl the_" ++ interfaceName ++ "_server_response_vtbl;"]
