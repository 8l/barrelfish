/*
 * Copyright (c) 2014 ETH Zurich. All rights reserved.
 *
 * This file is distributed under the terms in the attached LICENSE file.
 * If you do not find this file, copies can be found by writing to:
 * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
 */

/*
 * knc_sbox.dev
 *
 * description: intel e1000 family gigabit ethernet nics
 */

device knc_sbox lsbfirst ( addr base ) "intel xeon phi (knights corner) sbox" {

register oc_i2c_icr rw addr(base, 0x1000) "foo" { };
register thermal_status rw addr(base, 0x1018) "Status and Log info for all the thermal interrupts " {
        U32 thermal_monitor_status                         : 1; // bit 0 This bit is set whenever the current die temp exceeds the thermal monitor control temperature 
        U32 thermal_monitor_log                            : 1; // bit 1 This bit is a sticky version of Thermal_Monitor_Status, cleared by s/w or by reset 
        U32 out_of_spec_status                             : 1; // bit 2 This bit is set whenever the current die temp exceeds the Out of Spec temperature; is sticky 
        U32 out_of_spec_log                                : 1; // bit 3 This bit is also a sticky version of Out_Of_Spec_Status 
        U32 thermal_threshold1_status                      : 1; // bit 4 This bit is set whenever the current die temp exceeds the software programmed thermal threshold
        U32 thermal_threshold1_log                         : 1; // bit 5 This bit is a sticky version of Thermal_Threshold1_Status, cleared by s/w or by reset 
        U32 thermal_threshold2_status                      : 1; // bit 6 This bit is set whenever the current die temp exceeds the software programmed thermal threshold
        U32 thermal_threshold2_log                         : 1; // bit 7 This bit is a sticky version of Thermal_Threshold2_Status, cleared by s/w or by reset 
        U32 fan_monitor_status                             : 1; // bit 8 This bit is an indication if there was an error/fail condition with the Off-chip Fan  
        U32 fan_monitor_log                                : 1; // bit 9 This bit is a sticky version of Fan_Monitor_Status, cleared by s/w or by reset 
        U32 system_hot_status                              : 1; // bit 10 This bit is an indication if any other device on the MIC Card is hot 
        U32 system_hot_log                                 : 1; // bit 11 This bit is a sticky version of System_Hot_Status, cleared by s/w or by reset 
        U32 rsvd0                                          :20; // bit 12-31
 };


register thermal_interrupt_enable rw addr(base, 0x101c) " Register that controls the interrupt response to thermal events" {
	U32 high_temp_interrupt_enable			   : 1; // bit 0 This bit enables/disables the s/w programmed HIGH temp interrupt 
	U32 low_temp_interrupt_enable			   : 1; // bit 1 This bit enables/disables the s/w programmed  LOW temp interrupt 
	U32 out_of_spec_interrupt_enable		   : 1; // bit 2 This bit enables/disables the Out of Spec Temp interrupt 
	U32 fan_monitor_interrupt_enable		   : 1; // bit 3 This bit enables/disables the interrupt from Fan Control Unit	  
	U32 system_monitor_interrupt_enable		   : 1; // bit 4 This bit enables/disables the system hot interrupts 
	U32 mclk_ratio_interrupt_enable			   : 1; // bit 5 This bit enables/disables the mclk ratio interrupts 
	U32 alert_interrupt_enable			   : 1; // bit 6 This bit enables/disables the ALERT# interrupts 
	U32 gpuhot_interrupt_enable			   : 1; // bit 7 This bit enables/disables the GPUHOT# interrupts 
	U32 pwralert_interrupt_enable			   : 1; // bit 8 This bit enables/disables the PWRALERT# interrupt 
	U32 rsvd0					   : 1; // bit 9
	U32 sw_threshold1_temp				   :10; // bit 10-19 Software Programmable Thermal Threshold #1 
	U32 sw_threshold1_enable			   : 1; // bit 20 This bit enables/disables the sw threshold #1 interrupts 
	U32 sw_threshold2_temp				   :10; // bit 21-30 Software Programmable Thermal Threshold #2 
	U32 sw_threshold2_enable			   : 1; // bit 31 This bit enables/disables the sw threshold #2 interrupts  };
register status_fan1 rw addr(base, 0x1024) "foo" { };
register status_fan2 rw addr(base, 0x1028) "foo" { };
register speed_override_fan rw addr(base, 0x102c) "foo" { };
register board_temp1 rw addr(base, 0x1030) "foo" { };
register board_temp2 rw addr(base, 0x1034) "foo" { };
register board_voltage_sense rw addr(base, 0x1038) "foo" { };

register current_die_temp0 rw addr(base, 0x103c) "Consists of Current Die Temperatures of sensors 0 thru 2" {
        U32 sensor0_temp                                   :10; // bit 0-9 current Temperature of Sensor0
        U32 sensor1_temp                                   :10; // bit 10-19 current Temperature of Sensor1
        U32 sensor2_temp                                   :10; // bit 20-29 current Temperature of Sensor2
        U32 rsvd0                                          : 2; // bit 30-31
};


register current_die_temp1 rw addr(base, 0x1040) "Consists of Current Die Temperatures of sensors 0 thru 2" {
        U32 sensor0_temp                                   :10; // bit 0-9 current Temperature of Sensor0
        U32 sensor1_temp                                   :10; // bit 10-19 current Temperature of Sensor1
        U32 sensor2_temp                                   :10; // bit 20-29 current Temperature of Sensor2
        U32 rsvd0                                          : 2; // bit 30-31
}

;
register current_die_temp2 rw addr(base, 0x1044) "Consists of Current Die Temperatures of sensors 0 thru 2" {
        U32 sensor0_temp                                   :10; // bit 0-9 current Temperature of Sensor0
        U32 sensor1_temp                                   :10; // bit 10-19 current Temperature of Sensor1
        U32 sensor2_temp                                   :10; // bit 20-29 current Temperature of Sensor2
        U32 rsvd0                                          : 2; // bit 30-31
};


register max_die_temp0 rw addr(base, 0x1048) "foo" { };
register max_die_temp1 rw addr(base, 0x104c) "foo" { };
register max_die_temp2 rw addr(base, 0x1050) "foo" { };


register elapsed_time_low rw addr(base, 0x1074) "Elapsed Time Clock Timer - lower 32 bits" { 
	U32 elapsed_time_low				   :32; // bit 0-31 "Elapsed Time Clock" Timer - lower 32 bits
};


register elapsed_time_high rw addr(base, 0x1078) "Elapsed Time Clock Timer - higher 32 bits " { 
	U32 elapsed_time_high				   :32; // bit 0-31 "Elapsed Time Clock" Timer - higher 32 bits 
};


register fail_safe_offset rw addr(base, 0x2004) "foo" { };
register current_clk_ratio rw addr(base, 0x3004) "foo" { };
register smpt00 rw addr(base, 0x3100) "foo" { };
register smpt02 rw addr(base, 0x3108) "foo" { };
register rgcr rw addr(base, 0x4010) "foo" { };
register dstat rw addr(base, 0x4014) "foo" { };
register pcie_pci_revision_id_and_c_0x8 rw addr(base, 0x5808) "foo" { };
register pcie_bar_enable rw addr(base, 0x5cd4) "foo" { };


register sicr0 rw addr(base, 0x9004) "System Interrupt Cause Read Register 0 " { 
	U32 dbr						   : 5; // bit 0-4 This bit is set whenever the uOS requests an interrupt service from the host driver thru one of the four doorbells 
	U32 rsvd0					   : 3; // bit 5-7
	U32 dma						   : 8; // bit 8-15 DMA Channels 7:0 - This bit is set whenever the uOS or the host driver configures the DMA engine to issue an interrupt upon a DMA Transfer completion on one of the channels
	U32 rsvd1					   : 8; // bit 16-23
	U32 disprra					   : 1; // bit 24 Alloocation bit for Display Rendering Event Interrupt A
	U32 disprrb					   : 1; // bit 25 Alloocation bit for Display Rendering Event Interrupt B
	U32 dispnrr					   : 1; // bit 26 Display Non-Rendering Event Interrupt - This bit is set whenever the Dbox detects a non-rendering interrupt condition, which are display pipeline errors i.e. overrun and underruns and hot-plug detect. 
	U32 rsvd2					   : 3; // bit 27-29
	U32 sboxerr					   : 1; // bit 30 LEP Error interrupts like the PCU
	U32 spidone					   : 1; // bit 31 SPI Done Interrupt - This bit is set when the Sbox SPI controller is done with it's programmming operaiton


};


register sice0 rw addr(base, 0x900c) "foo" { };
register sicc0 rw addr(base, 0x9010) "foo" { };
register sicr1 rw addr(base, 0x901c) "foo" { };
register sicc1 rw addr(base, 0x9028) "foo" { };
register pmu_period_sel rw addr(base, 0x1070) "foo" { };


register thermal_status_interrupt rw addr(base, 0x107c) "Status and Log info for KNC new thermal interrupts" { 
	U32 mclk_ratio_status				   : 1; // bit 0 This bit is set whenever MCLK Ratio Changes. Cleared by SW writing. 
	U32 mclk_ratio_log				   : 1; // bit 1 This bit is also a sticky version of MCLK_Ratio_Status 
	U32 alert_status				   : 1; // bit 2 This bit is set whenever ALERT# pin is asserted. Cleared by SW writing. 
	U32 alert_log					   : 1; // bit 3 This bit is a sticky version of Alert_Status, cleared by s/w or by reset 
	U32 gpuhot_status				   : 1; // bit 4 This bit reflects the real-time value of the GPUHOT# pin (synchronized to SCLK domain). 
	U32 gpuhot_log					   : 1; // bit 5 This bit is set on the assertion edge of GPUHOT# and remains set until software clears it by doing a write. 
	U32 pwralert_status				   : 1; // bit 6 This bit reflects the real-time value of the PWRALERT# pin (synchronized to SCLK domain). 
	U32 pwralert_log				   : 1; // bit 7 This bit is set on the assertion edge of PWRALERT# and remains set until software clears it by doing a write. 
	U32 rsvd0					   :23; // bit 8-30
	U32 etc_freeze					   : 1; // bit 31 This bit freeze the increment of elapsed-time counter 
};


register thermal_status_2 rw addr(base, 0x1080) "foo" { };
register thermal_test_2 rw addr(base, 0x1084) "foo" { };


register corefreq rw addr(base, 0x4100) "Core Frequency " { 
	U32 ratio					   :12; // bit 0-11 Ratio
	U32 rsvd0					   : 3; // bit 12-14
	U32 fuseratio					   : 1; // bit 15 If overclocking is enabled, setting this bit will default the goal ratio to the fuse value.
	U32 asyncmode					   : 1; // bit 16 Async Mode Bit 16, Reserved Bits 20:17 used to be ExtClkFreq, 
	U32 rsvd1					   : 9; // bit 17-25
	U32 ratiostep					   : 4; // bit 26-29 Power throttle ratio-step
	U32 jumpratio					   : 1; // bit 30 Power throttle jump at once
	U32 booted					   : 1; // bit 31 Booted: This bit selects between the default MCLK Ratio (600MHz) and the programmable MCLK ratio. 0=default 1=programmable.


};


register corevolt rw addr(base, 0x4104) "Core Voltage" { 
	U32 vid						   : 8; // bit 0-7 VID
	U32 rsvd0					   :24; // bit 8-31

};


register memoryfreq rw addr(base, 0x4108) "foo" { };
register memvolt rw addr(base, 0x410c) "foo" { };
register sdbic0 rw addr(base, 0xcc90) "foo" { };
register sdbic1 rw addr(base, 0xcc94) "foo" { };
register sdbic2 rw addr(base, 0xcc98) "foo" { };
register sdbic3 rw addr(base, 0xcc9c) "foo" { };
register mxar0 rw addr(base, 0x9040) "foo" { };
register mxar0_k1om rw addr(base, 0x9044) "foo" { };
register mxar1 rw addr(base, 0x9044) "foo" { };
register mxar2 rw addr(base, 0x9048) "foo" { };
register mxar3 rw addr(base, 0x904c) "foo" { };
register mxar4 rw addr(base, 0x9050) "foo" { };
register mxar5 rw addr(base, 0x9054) "foo" { };
register mxar6 rw addr(base, 0x9058) "foo" { };
register mxar7 rw addr(base, 0x905c) "foo" { };
register mxar8 rw addr(base, 0x9060) "foo" { };
register mxar9 rw addr(base, 0x9064) "foo" { };
register mxar10 rw addr(base, 0x9068) "foo" { };
register mxar11 rw addr(base, 0x906c) "foo" { };
register mxar12 rw addr(base, 0x9070) "foo" { };
register mxar13 rw addr(base, 0x9074) "foo" { };
register mxar14 rw addr(base, 0x9078) "foo" { };
register mxar15 rw addr(base, 0x907c) "foo" { };
register msixpbacr rw addr(base, 0x9080) "foo" { };
register msixpbacr_k1om rw addr(base, 0x9084) "foo" { };
register dcar_0 rw addr(base, 0xa000) "foo" { };
register dhpr_0 rw addr(base, 0xa004) "foo" { };
register dtpr_0 rw addr(base, 0xa008) "foo" { };
register daux_lo_0 rw addr(base, 0xa00c) "foo" { };
register daux_hi_0 rw addr(base, 0xa010) "foo" { };
register drar_lo_0 rw addr(base, 0xa014) "foo" { };
register drar_hi_0 rw addr(base, 0xa018) "foo" { };
register ditr_0 rw addr(base, 0xa01c) "foo" { };
register dstat_0 rw addr(base, 0xa020) "foo" { };
register dstatwb_lo_0 rw addr(base, 0xa024) "foo" { };
register dstatwb_hi_0 rw addr(base, 0xa028) "foo" { };
register dcherr_0 rw addr(base, 0xa02c) "foo" { };
register dcherrmsk_0 rw addr(base, 0xa030) "foo" { };
register dcar_1 rw addr(base, 0xa040) "foo" { };
register dhpr_1 rw addr(base, 0xa044) "foo" { };
register dtpr_1 rw addr(base, 0xa048) "foo" { };
register daux_lo_1 rw addr(base, 0xa04c) "foo" { };
register daux_hi_1 rw addr(base, 0xa050) "foo" { };
register drar_lo_1 rw addr(base, 0xa054) "foo" { };
register drar_hi_1 rw addr(base, 0xa058) "foo" { };
register ditr_1 rw addr(base, 0xa05c) "foo" { };
register dstat_1 rw addr(base, 0xa060) "foo" { };
register dstatwb_lo_1 rw addr(base, 0xa064) "foo" { };
register dstatwb_hi_1 rw addr(base, 0xa068) "foo" { };
register dcherr_1 rw addr(base, 0xa06c) "foo" { };
register dcherrmsk_1 rw addr(base, 0xa070) "foo" { };
register dcar_2 rw addr(base, 0xa080) "foo" { };
register dhpr_2 rw addr(base, 0xa084) "foo" { };
register dtpr_2 rw addr(base, 0xa088) "foo" { };
register daux_lo_2 rw addr(base, 0xa08c) "foo" { };
register daux_hi_2 rw addr(base, 0xa090) "foo" { };
register drar_lo_2 rw addr(base, 0xa094) "foo" { };
register drar_hi_2 rw addr(base, 0xa098) "foo" { };
register ditr_2 rw addr(base, 0xa09c) "foo" { };
register dstat_2 rw addr(base, 0xa0a0) "foo" { };
register dstatwb_lo_2 rw addr(base, 0xa0a4) "foo" { };
register dstatwb_hi_2 rw addr(base, 0xa0a8) "foo" { };
register dcherr_2 rw addr(base, 0xa0ac) "foo" { };
register dcherrmsk_2 rw addr(base, 0xa0b0) "foo" { };
register dcar_3 rw addr(base, 0xa0c0) "foo" { };
register dhpr_3 rw addr(base, 0xa0c4) "foo" { };
register dtpr_3 rw addr(base, 0xa0c8) "foo" { };
register daux_lo_3 rw addr(base, 0xa0cc) "foo" { };
register daux_hi_3 rw addr(base, 0xa0d0) "foo" { };
register drar_lo_3 rw addr(base, 0xa0d4) "foo" { };
register drar_hi_3 rw addr(base, 0xa0d8) "foo" { };
register ditr_3 rw addr(base, 0xa0dc) "foo" { };
register dstat_3 rw addr(base, 0xa0e0) "foo" { };
register dstatwb_lo_3 rw addr(base, 0xa0e4) "foo" { };
register dstatwb_hi_3 rw addr(base, 0xa0e8) "foo" { };
register dcherr_3 rw addr(base, 0xa0ec) "foo" { };
register dcherrmsk_3 rw addr(base, 0xa0f0) "foo" { };
register dcar_4 rw addr(base, 0xa100) "foo" { };
register dhpr_4 rw addr(base, 0xa104) "foo" { };
register dtpr_4 rw addr(base, 0xa108) "foo" { };
register daux_lo_4 rw addr(base, 0xa10c) "foo" { };
register daux_hi_4 rw addr(base, 0xa110) "foo" { };
register drar_lo_4 rw addr(base, 0xa114) "foo" { };
register drar_hi_4 rw addr(base, 0xa118) "foo" { };
register ditr_4 rw addr(base, 0xa11c) "foo" { };
register dstat_4 rw addr(base, 0xa120) "foo" { };
register dstatwb_lo_4 rw addr(base, 0xa124) "foo" { };
register dstatwb_hi_4 rw addr(base, 0xa128) "foo" { };
register dcherr_4 rw addr(base, 0xa12c) "foo" { };
register dcherrmsk_4 rw addr(base, 0xa130) "foo" { };
register dcar_5 rw addr(base, 0xa140) "foo" { };
register dhpr_5 rw addr(base, 0xa144) "foo" { };
register dtpr_5 rw addr(base, 0xa148) "foo" { };
register daux_lo_5 rw addr(base, 0xa14c) "foo" { };
register daux_hi_5 rw addr(base, 0xa150) "foo" { };
register drar_lo_5 rw addr(base, 0xa154) "foo" { };
register drar_hi_5 rw addr(base, 0xa158) "foo" { };
register ditr_5 rw addr(base, 0xa15c) "foo" { };
register dstat_5 rw addr(base, 0xa160) "foo" { };
register dstatwb_lo_5 rw addr(base, 0xa164) "foo" { };
register dstatwb_hi_5 rw addr(base, 0xa168) "foo" { };
register dcherr_5 rw addr(base, 0xa16c) "foo" { };
register dcherrmsk_5 rw addr(base, 0xa170) "foo" { };
register dcar_6 rw addr(base, 0xa180) "foo" { };
register dhpr_6 rw addr(base, 0xa184) "foo" { };
register dtpr_6 rw addr(base, 0xa188) "foo" { };
register daux_lo_6 rw addr(base, 0xa18c) "foo" { };
register daux_hi_6 rw addr(base, 0xa190) "foo" { };
register drar_lo_6 rw addr(base, 0xa194) "foo" { };
register drar_hi_6 rw addr(base, 0xa198) "foo" { };
register ditr_6 rw addr(base, 0xa19c) "foo" { };
register dstat_6 rw addr(base, 0xa1a0) "foo" { };
register dstatwb_lo_6 rw addr(base, 0xa1a4) "foo" { };
register dstatwb_hi_6 rw addr(base, 0xa1a8) "foo" { };
register dcherr_6 rw addr(base, 0xa1ac) "foo" { };
register dcherrmsk_6 rw addr(base, 0xa1b0) "foo" { };
register dcar_7 rw addr(base, 0xa1c0) "foo" { };
register dhpr_7 rw addr(base, 0xa1c4) "foo" { };
register dtpr_7 rw addr(base, 0xa1c8) "foo" { };
register daux_lo_7 rw addr(base, 0xa1cc) "foo" { };
register daux_hi_7 rw addr(base, 0xa1d0) "foo" { };
register drar_lo_7 rw addr(base, 0xa1d4) "foo" { };
register drar_hi_7 rw addr(base, 0xa1d8) "foo" { };
register ditr_7 rw addr(base, 0xa1dc) "foo" { };
register dstat_7 rw addr(base, 0xa1e0) "foo" { };
register dstatwb_lo_7 rw addr(base, 0xa1e4) "foo" { };
register dstatwb_hi_7 rw addr(base, 0xa1e8) "foo" { };
register dcherr_7 rw addr(base, 0xa1ec) "foo" { };
register dcherrmsk_7 rw addr(base, 0xa1f0) "foo" { };
register dcr rw addr(base, 0xa280) "DMA Configuration Register" { 
    co0    1 "DMA Channel 0 Owner";
    ce0    1 "DMA Channel 0 Enable"; 
    co1    1 "DMA Channel 0 Owner";
    ce1    1 "DMA Channel 1 Enable"; 
    co2    1 "DMA Channel 0 Owner";
    ce2    1 "DMA Channel 2 Enable"; 
    co3    1 "DMA Channel 0 Owner";
    ce3    1 "DMA Channel 3 Enable"; 
    co4    1 "DMA Channel 0 Owner";
    ce4    1 "DMA Channel 4 Enable"; 
    co5    1 "DMA Channel 0 Owner";
    ce5    1 "DMA Channel 5 Enable"; 
    co6    1 "DMA Channel 0 Owner";
    ce6    1 "DMA Channel 6 Enable"; 
    co7    1 "DMA Channel 0 Owner";
    ce7    1 "DMA Channel 7 Enable"; 
    arb_h  8 "Arb H";
    arb_l  7 "Arb L";
    p      1 "Priority EN";
};
register apicicr0 rw addr(base, 0xa9d0) "foo" { };
register apicicr1 rw addr(base, 0xa9d8) "foo" { };
register apicicr2 rw addr(base, 0xa9e0) "foo" { };
register apicicr3 rw addr(base, 0xa9e8) "foo" { };
register apicicr4 rw addr(base, 0xa9f0) "foo" { };
register apicicr5 rw addr(base, 0xa9f8) "foo" { };
register apicicr6 rw addr(base, 0xaa00) "foo" { };
register apicicr7 rw addr(base, 0xaa08) "foo" { };
register scratch0 rw addr(base, 0xab20) "foo" { };
register scratch1 rw addr(base, 0xab24) "foo" { };
register scratch2 rw addr(base, 0xab28) "foo" { };
register scratch3 rw addr(base, 0xab2c) "foo" { };
register scratch4 rw addr(base, 0xab30) "foo" { };
register scratch5 rw addr(base, 0xab34) "foo" { };
register scratch6 rw addr(base, 0xab38) "foo" { };
register scratch7 rw addr(base, 0xab3c) "foo" { };
register scratch8 rw addr(base, 0xab40) "foo" { };
register scratch9 rw addr(base, 0xab44) "foo" { };
register scratch10 rw addr(base, 0xab48) "foo" { };
register scratch11 rw addr(base, 0xab4c) "foo" { };
register scratch12 rw addr(base, 0xab50) "foo" { };
register scratch13 rw addr(base, 0xab54) "foo" { };
register scratch14 rw addr(base, 0xab58) "foo" { };
register scratch15 rw addr(base, 0xab5c) "foo" { };
register rdmasr0 rw addr(base, 0xb180) "foo" { };
register sbq_flush rw addr(base, 0xb1a0 ) "foo" { };
register tlb_flush rw addr(base, 0xb1a4) "foo" { };
register gtt_phy_base rw addr(base, 0xc118) "foo" { };
register emon_cnt0 rw addr(base, 0xcc28) "foo" { };
register emon_cnt1 rw addr(base, 0xcc2c) "foo" { };
register emon_cnt2 rw addr(base, 0xcc30) "foo" { };
register emon_cnt3 rw addr(base, 0xcc34) "foo" { };
};
	


/************************************************************************* 
    Configuration CSR for GPU HOT 
*************************************************************************/
typedef union _sboxGpuHotConfigReg
{
    U32 value;
    struct
    {
        U32 enable_freq_throttle                           : 1; // bit 0 Enables Frequency Throttling initiated by someone outside MIC 
        U32 xxgpuhot_enable                                : 1; // bit 1 Enable MIC Assertion of XXGPUHOT 
        U32 rsvd0                                          :30; // bit 2-31
    } bits;
} sboxGpuHotConfigReg;

STATIC_ASSERT(sizeof(sboxGpuHotConfigReg) == sizeof(U32));


    The expected MCLK Ratio that is sent to the corepll 
*************************************************************************/
typedef union _sboxCurrentratioReg
{
    U32 value;
    struct
    {
	U32 mclkratio					   :12; // bit 0-11 This field contrains the actual MCLK ratio that the core is currently running at.  This may differ from the value programmed into the COREFREQ register due to thermal throttling or other events which force the MCLK ratio to a fixed value.
	U32 rsvd0					   : 4; // bit 12-15
	U32 goalratio					   :12; // bit 16-27 This field contrains the goal for the MCLK ratio..	 This may differ from the value programmed into the COREFREQ register due to thermal throttling or other events which force the MCLK ratio to a fixed value.  reset value needs to match corefreq.ratio RTL will use the corefreq.ratio reset value
	U32 rsvd1					   : 4; // bit 28-31
    } bits;
} sboxCurrentratioReg;


/************************************************************************* 
    SVID VR12/MVP7 Control Interace Register 
*************************************************************************/
typedef union _sboxSvidcontrolReg
{
    U32 value;
    struct
    {
	U32 svid_dout					   : 9; // bit 0-8 SVID DATA OUT Field
	U32 svid_cmd					   : 9; // bit 9-17 SVID Command Field
	U32 svid_din					   :11; // bit 18-28 SVID DATA IN Field
	U32 svid_error					   : 1; // bit 29 error indicator bit
	U32 svid_idle					   : 1; // bit 30 svid idle
	U32 cmd_start					   : 1; // bit 31 cmd start
    } bits;
} sboxSvidcontrolReg;


/************************************************************************* 
    Power Control Unit Register 
*************************************************************************/
typedef union _sboxPcucontrolReg
{
    U32 value;
    struct
    {
	U32 enablemclkpllshutdown			   : 1; // bit 0 This bit is set by Host OS to allow disabling of MCLK PLL to enter C3-state.  It is cleared by the Host OS to prevent the MCLK PLL from being shutdown by the PCU.  MCLK PLL will only be disabled if this bit is set AND all internal idle requirements have been met. 0=Disable MCLK Shutdown, 1-Allow MCLK Shutdown
	U32 mclk_enabled				   : 1; // bit 1 (read-only)This bit reflects the state of the PCU MCLK-Enable FSM.  It can be used as explicit feedback by SW to verify that successfully shutdown the MCLK PLL. 0=FSM not in MCLK_ENABLED state and MCLK is off.  1=FSM is in MCLK_ENABLED state and MCLK is running.
	U32 ring_active					   : 1; // bit 2 (read-only)This bit reflects the state of the ring-idle indicator coming from the Ring Box.  0=All Agents Idle, 1=At least one agent active
	U32 preventautoc3exit				   : 1; // bit 3 This bit is set by Host SW whenever it sets the VID value lower than it was when KNC entered Pkg-C3.	When set, any ring-bound PCIe transactions received by KNC will be completed without actually being sent to KNC ring, and an interrupt can be generated to the Host indicating this as an error condition.  This bit must be cleared for KNC to re-enable MCLK and exit C3. 0=Allow C3 Exit, 1=Prevent C3 Exit, Generate Error
	U32 ghost_active				   : 1; // bit 4 (read-only)This bit reflects the state of the Ghost Downstream Arbiter.  0=Idle, 1=At least one agent active
	U32 tcu_active					   : 1; // bit 5 (read-only) This bit reflects the state of the TCU(SBQ or DMA).  0=Idle, 1=At least one agent active
	U32 itp_sclkgatedisable				   : 1; // bit 6 (read-only)Status of the ITP sClk clock-gate disable, 1=disabled 
	U32 itp_pkgc3disable				   : 1; // bit 7 (read-only) Status of the ITP Pkg-C3 clock-gate disable, 1=disabled
	U32 c3mclkgateen				   : 1; // bit 8 This bit, when set, will cause the MCLK to be gated at each individual Ring Agent when KNC is in C3.	It should be set only when the EnableMclkPllShutdown (bit 0) is not set.  Disabling MCLK when in C3 can only occur when the correct idle conditions are true and this or EnableMclkPllShutdown fields are set.	1=Gate Mclk, 0=Do Not Gate MCLK
	U32 c3waketimer_en				   : 1; // bit 9 This bit, when set, loads the C3WakeUp timer with the 16-bit C3WakeTime field and enables the C3WakeUp timer to begin decrementing  while in AutoC3.  Clearing the disables the timer.	 HW will automatically clear this bit when the timer reaches zero or if AutoC3 exits. Writing a value of 0xFFFF to the C3WakeTimer will also clear this bit.
	U32 sysint_active				   : 1; // bit 10 (read-only) This bit reflects the state of the SYSINT.  0=Idle, 1=At least one pending interrupt
	U32 sclk_grid_off_disable			   : 1; // bit 11 Setting this bit will prevent the PCU logic from instructing the sclk PLL from gating the clock.
	U32 icc_dvo_ssc_cg_enable			   : 1; // bit 12 Clock gate:: ICC logic related to DVO SSC buffer for ssc clock for d2d 1=clock gated
	U32 icc_core_ref_clock_cg_enable		   : 1; // bit 13 Clock gate: ICC logic related to Core Reference clock:  1=clock gated 
	U32 icc_gddr_ssc_cg_enable			   : 1; // bit 14 Clock Gate: ICC Logic relted to GDDR SSC buffer 1=clock gated
	U32 icc_pll_disable				   : 1; // bit 15 This bit can be set by Host SW to shutdown the ICC PLL.  This should only be done once MCLK PLL is already shutdown.	This bit must be cleared at least 50us before reenabling MCLK.
	U32 mclk_pll_lock				   : 1; // bit 16 This bit contains the value of hte actual MCLK PLL lock bit. Primarily for debug.  1=locked
	U32 groupb_pwrgood_mask				   : 1; // bit 17 Clock Gate: ICC Logic relted to GDDR SSC buffer 1=clock gated
	U32 rsvd0					   :14; // bit 18-31
    } bits;
} sboxPcucontrolReg;
