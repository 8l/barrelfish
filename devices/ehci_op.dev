/*
 * Copyright (c) 2009, ETH Zurich. All rights reserved.
 *
 * This file is distributed under the terms in the attached LICENSE file.
 * If you do not find this file, copies can be found by writing to:
 * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
 */

/*
 * ehci.dev
 *
 * DESCRIPTION: Enhanced Host Controller Interface description
 *
 * Numbers in comments refer to the Intel EHCI documentation at
 * http://www.intel.com/technology/usb/download/ehci-r10.pdf
 */

device ehci_op msbfirst ( addr base1) "Intel EHCI operational registers" 
{

/* Section 2.3
 * Host controller operational registers
 */

 
 // Valid values for interrupt threashold control, specifies the maximum 
 // rate at which host controller will issue interrupts.
 // Used in: USB command register
 
 constants itc_val "Interrupt threshold control" {
   itc_val_rsvd  = 0x00  "Reserved";
   uframe_1      = 0x01  "1 Micro frame";
   uframes_2     = 0x02  "2 Micro frames";
   uframes_4     = 0x04  "4 Micro frames";
   uframes_8     = 0x08  "8 Micro frames (default, equates to 1 ms)";
   uframes_16    = 0x10  "16 Micro frames (2 ms)";
   uframes_32    = 0x20  "32 Micro frames (4 ms)";
   uframes_64    = 0x40  "64 Micro frames (8 ms)";
  };


 // Valid values for the size of frame list. The size the frame list controls 
 // which bits in the Frame Index Register should be for the Frame List 
 // Current index. 
 // Used in: USB command register

 constants frame_val "Frame list size" {
    elem_1024    = 0b00   "1024 Elements (4096 bytes, default)";
    elem_512     = 0b01   "512 Elements (2048 bytes)";
    elem_256     = 0b10   "256 Elements (1024 bytes)";
    frame_val_rsvd     = 0b11   "Reserved";
  };

 // section 2.3.1 USB command register
 register usb_cmd rw addr(base1, 0x00) "USB command register" {

   _       8    mbz;
   itc     8    type(itc_val) "Interrupt threshold control";
   _       4    mbz;
   aspm_e  1    rw               "Asynchronous schedule park mode enable";
   _       1    mbz;
   aspm_c  2    rw               "Asynchronous schedule park mode count";
   lhcr    1    rw               "Light host controller reset";
   iaad    1    rw               "Interrupt on async advance doorbell";
   as_e    1    rw               "Asynchronous schedule enable";
   ps_e    1    rw               "Periodic schedule enable";
   fl_sz   2    type(frame_val)  "Frame list size";
   hcr     1    rw               "Host controller reset";
   rs      1    rw               "Run stop for scheduling";
 };

 
 // section 2.3.2 USB status register 
 register usb_status rw addr(base1, 0x04) "USB status register" {
   _        16   mbz;
   as_s     1    ro   "Asynchronous schedule status";
   ps_s     1    ro   "Periodic schedule status";
   rec      1    ro   "Reclamation";
   hc_halt  1    ro   "Host controller halted see Run/Stop";   
   _        6    mbz;
   i_aa     1    rwc  "Interrupt on Async advance";
   hs_err   1    rwc  "Host system error";
   flr      1    rwc  "Frame list rollover";
   pcd      1    rwc  "Port change detect";
   usb_ei   1    rwc  "USB error interrupt";
   usb_i    1    rwc  "USB interrupt";
  };

 // section 2.3.3 USB interrupt enable register 
 register usb_int rw addr(base1, 0x08) "USB interrupt enable register" {
   _       26   mbz;
   iaa_e   1    rw   "Interrupt on async advance enable";
   hye_e   1    rw   "Host system error enable";
   flr_e   1    rw   "Frame list rollover enable";
   pci_e   1    rw   "Port change interrupt enable";
   usbei_e 1    rw   "USB error interrupt enable";
   usbi_e  1    rw   "USB interrupt enable";
  };

 // section 2.3.4 Frame index register 
 register frame_index rw addr(base1, 0x0C) "Frame index register" {
  _    18  mbz;
  fi   14  rw   "Frame index";
  };

 // section 2.3.5 Control data structure segment register
 // NOTE: Only enabled if 64 bit address capability is enabled 
  register ctrl_dss_reg rw addr(base1, 0x10) "Control data structure segment register" {
   data 32 rw "MSB [63:32] bits of EHCI data strctures";
 };

 // section 2.3.6 32-Bit register conatianing beginning address of 
 // periodic frame list in system memory.
 register flba_reg rw addr(base1, 0x14) "Periodic frame list base address register" {
    addr   20   rw    "Base address (must be 4k aligned)";
    _      12   mbz; 
  };

 //section 2.3.7 Address of next asynchronous queue head to be executed 
 register asyn_list_reg rw addr(base1, 0x18) "Current asynchronous list address register" {
   lpl    27   rw   "Link pointer low";
   _      5    mbz;
  };

 //section 2.3.8 Configure flag register 
 register config_flag rw addr(base1, 0x40) "Configure flag register" {
   _     31   mbz;
   cf    1    rw   "Config flag";
  };

 //section 2.3.9 Port status and Control register
 // Number of registers is not fixed hence use regtype and then make an array 

  // Bits [19:16]
 constants test_mode_val "Test mode valid values" {
   DIS       =  0b0000   "Test mode not enabled";
   J_STATE   =  0b0001   "Test J_STATE";
   K_STATE   =  0b0010   "Test K_STATE";
   SE0_NAK   =  0b0011   "Test SE0_NAK";
   TEST_PACK =  0b0100   "Test packet";
   FORCE_ENA =  0b0101   "Force enable";
 };
  
 // Bits [15:14] 
 constants indi_val "Port indicator valid values" {
   off                = 0b00  "Port indicators are off";
   amber              = 0b01  "Amber";
   green              = 0b10  "Green";
   indi_val_undef     = 0b11  "Undefined";
  };     
 
 // Bits [11:10] 
 constants lstatus_val "USB line status" {
   SE0                  =  0b00   "Not low speed device, perform EHCI reset";
   j_state              =  0b10   "Not low speed device, perform EHCI reset";
   k_state              =  0b01   "Low speed device, release ownership of port";
   lstatus_val_undef    =  0b11   "Not low speed device, perfrom EHCI reset"; 
  };

 regtype portsc "Port status and control register" {
   _            9     mbz;
   wkoc_e       1     rw                  "Wake on over-current enable";
   wkdscnnt_e   1     rw                  "Wake on disconnect enable";
   wkcnnt_e     1     rw                  "Wake on connect enable";
   p_tc         4     type(test_mode_val) "Port test control";
   p_ic         2     type(indi_val)      "Port indicator control";
   p_owner      1     rw                  "Port owner";
   p_power      1     rw                  "Port power";
   line_status  2     type(lstatus_val)   "Line status value";
   _            1     mbz;
   p_reset      1     rw                  "Port reset";
   p_suspend    1     rw                  "Port suspend";
   p_resume     1     rw                  "Force port resume";
   occ          1     rwc                 "Over current change";
   oca          1     ro                  "Over current active";
   p_edc        1     rwc                 "Port enable/disbale change";
   p_ed         1     rw                  "Port enabled/disabled";
   csc          1     rwc                 "Connect status change";
   ccs          1     ro                  "Current connect status";
  };
  
 // XXX: This number is statically allocated because Mackerel 
 // does not support variables or run time variable allocation. 
 // number = hcs_param.n_pcc;  // Which is a 4 bit number hence 15 
 
 regarray portsc_arr rw addr(base1, 0x44) [15] "Port Status" type(portsc);

}; // End of device 
